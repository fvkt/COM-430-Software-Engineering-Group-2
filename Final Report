Module 8, Software Development Project


Carlos Silva / Cody Bradley / Joseph Prignano
Student, Saint Leo University
COM-430-OL01 Software Engineering, Module 8, Software Development Project
Professor Dr. Brian Holbert
December 14, 2025
 

Module 8, Writing Software Development Project:

Software Development Report: Pet Rock Genie Application
Introduction:
The Pet Rock Genie application represents a practical implementation of fundamental software engineering principles within a command-line oracle interface. Developed by Group 2 for COM-430 Software Engineering, this project demonstrates how traditional software development methodologies apply to modern Python applications. Our team consisting of Carlos Silva, Cody Bradley, and Joseph Prignano employed an iterative development approach using GitHub for version control and collaborative coding and Discord for group communication. This report examines the software engineering approaches and process model components used throughout the project's lifecycle, from start conception through finish deployment at version 2.1.0.
Software Engineering Approaches
Our development of Pet Rock Genie primarily followed an iterative and incremental approach combined with elements of agile methodology. This hybrid strategy proved effective for our small team and relatively focused project scope. We began with a minimal viable product (MVP) in version 1.0.0 that provided basic yes/no/maybe functionality, then systematically polished and ehanced the application through version 2.0.0 to the final 2.1.0 release.
The object-oriented programming (OOP) paradigm formed the architectural foundation of our application. We encapsulated all primary functionality within the PetRockGenie class, which takes charge of state through instance variables like question_count and responses. This design decision supports modularity and reusability, two vital software engineering principles. As Sommerville notes in Software Engineering, "object-oriented design is concerned with developing an object-oriented model of a software system to implement identified requirements" (2016, p. 178). Our class-based structure enables potential future scalability, such as adding multiple oracle personalities or integrating with external APIs, without requiring fundamental architectural changes.
We also incorporated defensive programming techniques throughout the codebase. The application includes comprehensive error handling for various edge cases: empty user inputs, keyboard interrupts, and unexpected exceptions. This approach aligns with the software engineering principle that "programs should be written to continue operating even when unexpected conditions occur" (Pressman & Maxim, 2015, p. 445). For instance, our try-except blocks gracefully catch KeyboardInterrupt exceptions and provide user-friendly exit messages rather than displaying confusing Python stack traces.
Some might argue that such extensive error handling is unnecessary for a simple command-line application. However, this perspective overlooks the educational value and professional standards we aimed to demonstrate. Even small projects like ours can reap rewards from robust error management, and the habits formed during academic work are carried forward into professional development environments. Furthermore, the logging system we implemented which tracks every question, answer, and errors provides debugging capabilities that would be absent in a more casually constructed application.
Common Process Model Components
Our development process incorporated several standard process model components, beginning with requirements analysis. We identified five core specifications: basic functionality (yes/no/maybe responses), user interface (command-line interaction), logging capabilities, error handling, and code reusability. These requirements guided our entire development effort and provided clear success criteria. The transition from version 1.0.0 to 2.0.0 demonstrates how we refined our understanding of these requirements based on initial implementation experience.
Design represented our second major process component. We created a simple, yet effective architecture centered on the PetRockGenie class with clearly defined methods: __init__() for initialization, get_answer () for response generation, and run () for the main interaction loop. We established application constants at the module level (VALID_EXIT_COMMANDS, VALID_ANSWER_TYPES, RESPONSES) to separate configuration data from logic. This design pattern exemplifies what Hunt and Thomas describe as the "DRY principle “Don’t Repeat Yourself—in The Pragmatic Programmer (2020, p.32). By centralizing our response strings and valid commands, we made the codebase more maintainable and easier to modify.
The implementation phase leveraged GitHub for version control and collaborative development. We worked iteratively with each team member contributing to different aspects of the codebase. Carlos Silva focused on core application logic and system architecture, Cody Bradley handled quality assurance and error handling, and Joseph Prignano managed documentation and logging integration. This division of labor reflects professional software development practices where specialists contribute to their areas of expertise while maintaining overall code cohesion.
Testing and validation occurred continuously throughout development rather than as a discrete final phase. We tested user input validation, response randomization, logging accuracy, and error handling through both automated script execution and manual interaction. The promotion from "Test Environment" status in version 2.0.0 to "Final Version" 2.1.0 formalized our testing progression. Our logging system proved invaluable during this phase, as it allowed us to review application behavior across multiple sessions and verify that all features functioned as intended.
Critics of lightweight methodologies might argue that our project lacked formal documentation like UML diagrams or detailed design specifications. While true, this criticism misses the context of our development constraints. For a three-person team working on a relatively simple application over a limited timeframe, extensive formal documentation would have provided diminishing returns. Instead, we invested in clear code comments, docstrings, and a comprehensive README file—documentation approaches more aligned with modern agile practices that prioritize "working software over comprehensive documentation" (Beck et al., 2001, Agile Manifesto).
Maintenance and evolution components emerged through our version progression. Version 2.0.0 introduced "enhanced documentation," "improved user input handling," and "expanded logging" without altering core functionality, a maintenance activity focused on code quality rather than feature addition. The structured comment blocks we added (delimited by lines of dashes) improve code navigation, while our module-level metadata facilitates future developers' understanding of the codebase. This attention to maintainability demonstrates our awareness that software engineering extends beyond initial development to encompass the entire software lifecycle.
Configuration Management and Version Control
Our use of GitHub for development exemplifies proper configuration management, another essential process model component. We maintained clear version identifiers (1.0.0, 2.0.0, 2.1.0) following semantic versioning conventions, where major version numbers indicate significant changes and minor numbers represent incremental improvements. The transition from "Test Environment" to "Final Version" in our code comments and print statements reflects professional deployment practices where code progresses through defined stages before production release.
The README documentation we created serves multiple process model functions. It provides installation instructions (supporting deployment), usage guidelines (supporting operation), and version history (supporting maintenance). By explicitly noting "This project is for academic purposes only," we also addressed legal and ethical consideration aspects of software engineering that students sometimes overlook but that carry significant professional importance.
Conclusion
The Pet Rock Genie application, despite its playful premise, demonstrates serious software engineering principles in practice. Through our iterative development approach, object-oriented design, defensive programming techniques, and structured process components, we created a maintainable, well-documented application that meets all specified requirements. The project illustrates how established software engineering methodologies scale down effectively to small applications while preparing developers for larger, more complex systems.
Our experience reinforces that software engineering is fundamentally about systematic approaches to software development, regardless of project size. The same principles that guide enterprise application development modularity, error handling, version control, testing, and documentation prove are valuable even for a simple command-line oracle. As we transition from academic to professional software development environments, the practices demonstrated in this project provide a solid foundation for tackling more ambitious engineering challenges.


References

Beck, K., et al. (2001). Manifesto for Agile Software Development. Agile Alliance.
Hunt, A., & Thomas, D. (2020). The Pragmatic Programmer: Your Journey to Mastery 
(20th Anniversary Edition). Addison-Wesley Professional.
Pressman, R. S., & Maxim, B. R. (2015). Software Engineering: A Practitioner's 
Approach (8th ed.). McGraw-Hill Education.
Sommerville, I. (2016). Software Engineering (10th ed.). Pearson.

